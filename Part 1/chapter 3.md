# 第一部分:虚拟化
分为两点 CPU虚拟化和内存虚拟化

## 抽象:进程

时分共享CPU技术:允许用户如愿运行多个并发进程,潜在的开销就是性能损失,如果CPU必须共享,每个进程的运行就会慢一点
操作系统的低级机制,高级策略
低级机制:上下文切换(可以让操作系统停止运行某个程序,并开始让CPU运行另一个程序)
高级策略:让操作系统做出某种决定的算法. 调度策略(根据历史信息 负载情况 性能指标来决定执行哪一个程序)


在任何时刻,我们都可以清点它在执行过程中访问或影响的系统的不同部分
进程的机器状态
- 地址空间: 数据内存指令内存
- 寄存器 : 程序计数器(PC) 栈指针 帧指针 
- 文件列表

## 进程创建

程序如何转化为进程 操作系统如何启动并运行一个程序 进程创建实际如何进行???

1: 将代码和所有静态数据加载到内存中, 操作系统从磁盘读取这些字节 放到内存中 
**惰性加载:仅在程序执行期间需要加载的代码或数据片段才会加载**
2: 为程序的运行时栈,堆 分配一些内存
**C语言使用栈存放局部变量,函数参数和返回地址**
3: 会执行与输入输出(I/O)相关的任务,对于 UNIX 默认情况下每个进程都有3个打开的文件描述符,用于标准输入,输出,错误
4: 启动程序,在入口处运行 即main()

## 进程状态
- 运行 该进程正在处理器上运行
- 就绪 进程已准备好运行,操作系统选择不在此时运行
- 阻塞 进程执行了某种操作,直到发生其他事件时才会准备运行 (发起IO IO完成) (等待接收网络数据包,接收完成)

## 操做系统数据结构

了解一下 有关操作系统的数据结构,后面进一步学习xv6的时候,再仔细了解操作系统的内部结构

- 为所有就绪的进程保留某种进程列表

```C
struct context
{
    int eip;
    int esp;
    int ebx;
    int ecx;
    int edx;
    int esi;
    int edi;
    int ebp;
};
enum proc_state{UNUSED, EMBRYO, SLEEPING, RUNNABLE, RUNNING, ZOMBIE};
struct proc
{
    char *mem;
    uint sz;
    char *kstack;

    enum proc_state state;
    int pid;
    struct proc *parent;
    void *chan;
    int killed;
    struct file *ofile[NOFILE];
    struct context context;
    struct trapframe *tf;
}

```