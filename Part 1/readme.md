操作系统导论

> 一直不知道读书笔记怎么写,也读过几本计算机方向的著作,但是总感觉遗忘的很快,书里的内容学习完确实会感觉到收获满满,我想读完一本书的会花很多时间,我在回顾这本书的内容时,并不是一件特别容易的,想边读一本书,边记录一下这本书每个章节的思想.也许会有一些内容用书里的原话表述.也许这份读书笔记会有些臃肿几十页.
Ps::这本书的代码部分,我专门用code文件夹存放

# 关于本书的对话

我们会学习到三个关键概念 虚拟化 并发 持久性,通过这三个概念，我们将理解操作系统是如何工作的，包括它如何决定接下来哪个程序使用 CPU，如何在虚拟内存系统中处理内存使用过载，虚拟机监控器如何工作，如何管理磁盘上的数据，还会讲一点如何构建在部分节点失败时仍能正
常工作的分布式系统

# 操作系统介绍

操作系统 负责让程序运行变得容易(可以同时运行多个程序) 允许程序共享内存,与设备交互
虚拟化技术 操作系统可以将物理资源(内存 处理器 磁盘)转换为更通用 更强大且更易于使用的虚拟形式
操作系统提供了一些API接口,可以利用这些API接口(系统调用) 来运行程序,访问内存和设备
要运行程序甚停止它们，或告诉操作系统运行哪些程序，需要有一些接口(API)，你可以利用它们将需求传达给操作系统。
虚拟化 让许多程序运行(共享CPU),访问指令内存和数据内存(共享内存),访问设备(共享磁盘)

## 虚拟化CPU
当我们同时运行两个程序的时候 会发现他们是交替执行的
```
./2.1-cpu.c "A"& ./2.1-cpu.c "B"&
```
就好像两个程序同时执行 同时在使用CPU

操作系统负责提供这种假象，即系统拥有非常多的虚拟 CPU 的假象。将单个 CPU（或其中一小部分）转换为看似无限数量的 CPU，从而让许多程序看似同时运行，这就是所谓的虚拟化CPU
## 虚拟化内存
在我们调用malloc() api,来分配一些内存时,我们可以通过操作 对内存进行读写,也可以让多个程序共享内存,
```
./2.2-mem & ./2.2-mem &
```
每个进程访问自己的私有虚拟地址空间（有时称为地址空间），操作系统以某种方式映射到机器的物理内存上。一个正在运行的程序中的内存引用不会影响其他进程（或操作系统本身）的地址空间。对于正在运行的程序，它完全拥有自己的物理内存

## 并发
可以将线程看作与其他函数在同一内存空间中运行的函数,并且每次都有多个线程处于活动状态
在一个程序创建两个线程,每个线程都执行一个循环,计数loop次,按道理来说应该计数了 2*loops次 可是,有很多时候输出的值看似是一个随机的
```
./2.3-threads 10000
```
这些不寻常的结果与指令如何执行有关，指令每次执行一条。程序中的关键部分是增加共享计数器的地方，它需要 3 条指令：一条将计数器的值从内存加载到寄存器，一条将其递增，另一条将其保存回内存。因为这 3 条指令并不是以原子方式执行（所有的指令一次性执行）的

>GPT给出的解答是:
>这是因为在该程序中，counter++ 操作并不是一个原子操作。多个线程可能同时访问counter 变量并试图递增它，这可能导致一些递增操作被丢失，从而导致 counter 的最终值小于预期的值。要解决这个问题，可以使用同步机制，如互斥锁或原子操作，来确保对 counter 变量的访问始终是原子的。这样可以保证对该变量的操作不会同时被多个线程执行，从而避免数据竞争并保证计数器的正确性



## 持久性
持久性是指 在系统内存中,数据容易丢失(断电或系统崩溃),而硬盘可以更持久地存储数据.
不像内存和CPU那样,操作系统为其提供了抽象,操作系统不会为每个应用程序创建专用的虚拟磁盘多个程序同时使用磁盘资源,共享文件信息(磁盘资源)

> 这个章节应该是这本书的一个综述,会介绍到很多抽象的概念和一些简单的实现策略,刚开始阅读会有一些屏障,但我相信读完这本书再来看这一章时,会有一种焕然一新的感觉





# 第一部分:虚拟化
分为两点 CPU虚拟化和内存虚拟化

